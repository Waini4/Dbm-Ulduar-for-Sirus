-- ***************************************************
-- **             DBM Range Check Frame             **
-- **                                               **
-- ***************************************************

DBM.MapSizes = {
	AhnQiraj = {{2777.544, 1851.696}, {977.56, 651.707}, {577.56, 385.04}},
	Ahnkahet = {{972.418, 648.279}},
	Alterac = {{2800.0003, 1866.6667}},
	AlteracValley = {{4237.5, 2825}},
	Arathi = {{3600.0004, 2399.9997}},
	ArathiBasin = {{1756.2497, 1170.833}},
	Ashenvale = {{5766.667, 3843.7504}},
	Aszhara = {{5070.833, 3381.25}},
	AuchenaiCrypts = {{742.5404, 495.027}, {817.5405, 545.027}, {274.9072, 27.3938}, {392.4072, 119.8937}},
	Azeroth = {{40741.18, 27149.68}},
	AzjolNerub = {{752.974, 501.983}, {292.974, 195.316}, {367.5, 245}},
	AzuremystIsle = {{4070.83, 2714.583}},
	Badlands = {{2487.5, 1658.334}},
	Barrens = {{10133.334, 6756.25}},
	Battleground01 = {{2079.7536, 1376.9428}},
	BlackTemple = {{1252.24946, 834.833}, {975, 650}, {1005, 670}, {440.001, 293.334}, {670, 446.6664}, {705, 470}, {355, 236.6666}},
	BlackfathomDeeps = {{884.22, 589.48}, {884.22, 589.48}, {284.224, 189.4827}},
	BlackrockDepths = {{1407.061, 938.0403}, {1507.061, 1004.7072}},
	BlackrockSpire = {{886.839, 591.226}, {886.839, 591.226}, {886.839, 591.226}, {886.839, 591.226}, {886.839, 591.226}, {886.839, 591.226}, {886.839, 591.226}},
	BlackwingLair = {{499.428, 332.95}, {649.427, 432.95}, {649.427, 432.95}, {649.427, 432.95}},
	BladesEdgeMountains = {{5425, 3616.6664}},
	BlastedLands = {{3350, 2233.33}},
	BloodmystIsle = {{3262.5, 2174.9997}},
	BoreanTundra = {{5764.583, 3843.75}},
	BurningSteppes = {{2929.1663, 1952.083}},
	ClassicMountHyjal = {{2500, 1666.666}},
	CoTHillsbradFoothills = {{2331.2503, 1554.166}},
	CoTMountHyjal = {{2500, 1666.666}},
	CoTStratholme = {{1125.3, 750.2}},
	CoTTheBlackMorass = {{1087.5, 725}},
	CoilfangReservoir = {{1575.0025, 1050.002}, {1573.998, 1050.002}},
	CrystalsongForest = {{2722.917, 1814.583}},
	Dalaran = {{830.015, 553.34}},
	DalaranSewerage = {{563.224, 375.49}},
	Darkshore = {{6550, 4366.666}},
	Darnassis = {{1058.333, 705.733}},
	DeadwindPass = {{2499.9997, 1666.664}},
	Desolace = {{4495.833, 2997.9163}},
	DireMaul = {{1275, 850}, {525, 350}, {487.5, 325}, {750, 500}, {800.0008, 533.334}, {975, 650}},
	Dragonblight = {{5608.333, 3739.583}},
	DrakTharonKeep = {{619.941, 413.294}, {619.941, 413.294}},
	DunMorogh = {{4925, 3283.334}},
	Durotar = {{5287.5, 3525}},
	Duskwood = {{2700.0003, 1800.004}},
	Dustwallow = {{5250.0001, 3500}},
	EasternPlaguelands = {{4031.25, 2687.5}},
	Elwynn = {{3470.834, 2314.587}},
	EversongWoods = {{4925, 3283.337}},
	Expansion01 = {{17464.079, 11642.718}},
	Felwood = {{5750, 3833.333}},
	FelyardMain = {{8533.2, 8533.2}},
	Feralas = {{6950, 4633.333}},
	Ghostlands = {{3300, 2199.999}},
	Gnomeregan = {{769.668, 513.112}, {769.668, 513.112}, {869.668, 579.778}, {869.6697, 579.78}},
	GrizzlyHills = {{5250, 3500}},
	GruulsLair = {{525, 350}, {525, 350}},
	Guildhouse_v1_alliance = {{533, 533}},
	Guildhouse_v1_horde = {{534, 533}},
	Guildhouse_v2_alliance = {{533, 533}},
	Guildhouse_v2_horde = {{534, 533}},
	Gundrak = {{905.033, 603.35}},
	HallsofLightning = {{566.235, 377.49}, {708.237, 472.16}},
	HallsofReflection = {{879.02, 586.02}},
	Hellfire = {{5164.583, 3443.75}},
	HellfireRamparts = {{694.56, 463.04}},
	Hilsbrad = {{3200, 2133.333}},
	Hinterlands = {{3850, 2566.667}},
	HowlingFjord = {{6045.833, 4031.2503}},
	HrothgarsLanding = {{3677.0836, 2452.084}},
	IcecrownCitadel = {{1355.47, 903.647}, {1067, 711.3337}, {195.47, 130.315}, {773.71, 515.81}, {1148.74, 765.82}, {373.71, 249.13}, {293.26, 195.507}, {247.93, 165.288}},
	IcecrownGlacier = {{6270.8333, 4181.25}},
	Ironforge = {{790.6246, 527.605}},
	IsleofConquest = {{2650, 1766.66633}},
	Kalimdor = {{36799.81, 24533.2}},
	Karazhan = {{550.048, 366.7}, {257.86, 171.9}, {345.15, 230.1}, {520.048, 346.7}, {234.15, 156.1}, {581.548, 387.7}, {191.548, 127.7}, {139.35, 92.900000000001}, {760.048, 506.7}, {450.25, 300.16}, {271.05, 180.7}, {595.048, 396.7}, {529.048, 352.7}, {245.25, 163.5}, {211.15, 140.76}, {101.25, 67.5}, {341.25, 227.5}, {550.049, 366.7}, {257.86, 171.9}, {345.15, 230.1}, {520.049, 346.7}, {234.15, 156.1}, {581.549, 387.7}, {191.549, 127.7}, {139.35, 92.900000000001}, {760.049, 506.7}, {450.25, 300.16}, {271.05, 180.7}, {595.049, 396.7}, {529.049, 352.7}, {245.25, 163.5}, {211.15, 140.76}, {101.25, 67.5}, {341.25, 227.5}},
	LakeWintergrasp = {{2975, 1983.334}},
	LochModan = {{2758.333, 1839.583}},
	Lost_island_map_ = {{3733, 3732}},
	MagistersTerrace = {{530.334, 353.55594}, {530.334, 353.55599}},
	MagtheridonsLair = {{556, 370.6667}},
	ManaTombs = {{823.2852, 548.8568}},
	Maraudon = {{975, 650}, {1637.5, 1091.666}},
	MoltenCore = {{1264.8, 843.199}},
	Moonglade = {{2308.333, 1539.583}},
	Mulgore = {{5137.5, 3425.0003}},
	Nagrand = {{5524.997, 3683.33366}},
	Naxxramas = {{1093.83, 729.22}, {1093.83, 729.22}, {1200, 800}, {1200.33, 800.22}, {2069.81, 1379.88}, {655.94, 437.29}},
	Netherstorm = {{5574.99966, 3716.667}},
	NetherstormArena = {{2270.8337, 1514.583}},
	Nexus80 = {{514.707, 343.139}, {664.707, 443.139}, {514.707, 343.139}, {294.701, 196.464}},
	Northrend = {{17751.398, 11834.27}},
	Ogrimmar = {{1402.605, 935.416}},
	PitofSaron = {{1533.3333, 1022.9167}},
	RazorfenDowns = {{709.049, 472.7}},
	RazorfenKraul = {{736.45, 490.96}},
	Redridge = {{2170.834, 1447.92}},
	RuinsofAhnQiraj = {{2512.5004, 1675}},
	STVDiamondMineBG = {{915.506, 610.3371}},
	ScarletEnclave = {{3162.5, 2108.3334}},
	ScarletMonastery = {{619.984, 413.322}, {320.191, 213.4605}, {612.6966, 408.46}, {703.3, 468.8663}},
	Scholomance = {{320.0489, 213.365}, {440.049, 293.3664}, {410.078, 273.3858}, {531.042, 354.0282}},
	SearingGorge = {{2231.2503, 1487.5}},
	SethekkHalls = {{703.4954, 468.997}, {703.4954, 468.997}},
	ShadowLabyrinth = {{841.5224, 561.0149}},
	ShadowfangKeep = {{352.43, 234.9534}, {212.426, 141.618}, {152.43, 101.61993}, {152.43, 101.6247}, {152.43, 101.6247}, {198.43, 132.28661}, {272.43, 181.61993}},
	ShadowmoonValley = {{5500, 3666.666}},
	ShattrathCity = {{1306.25, 870.834}},
	SholazarBasin = {{4356.25, 2904.167}},
	Silithus = {{3483.334, 2322.916}},
	SilvermoonCity = {{1211.458, 806.772}},
	Silverpine = {{4200, 2800}},
	Sirus2 = {{2666, 2666}},
	Sirus3 = {{2666, 2666}},
	Sirus4 = {{2667, 2666}},
	Sirus8 = {{4789, 4789}},
	StonetalonMountains = {{4883.333, 3256.2503}},
	Stormwind = {{1737.50033, 1158.333}},
	StrandoftheAncients = {{1743.7499, 1162.4997}},
	Stranglethorn = {{6381.25, 4254.17}},
	Stratholme = {{705.72, 470.48}, {1005.72, 670.48}},
	Sunwell = {{3327.083, 2218.75}},
	SunwellPlateau = {{465, 310}},
	SwampOfSorrows = {{2293.75, 1529.167}},
	Tanaris = {{6900, 4600}},
	Teldrassil = {{5091.666, 3393.75}},
	TempestKeep = {{1575, 1050}},
	TerokkarForest = {{5400, 3600.0001}},
	TheArcatraz = {{689.684, 459.78933}, {546.048, 364.032}, {636.684, 424.456}},
	TheArgentColiseum = {{369.9862, 246.658}, {369.9862, 246.658}, {739.996, 493.33}},
	TheBloodFurnace = {{1003.519, 669.0127}},
	TheBotanica = {{757.4024, 504.935}},
	TheDeadmines = {{559.264, 372.8425}, {499.263, 332.8423}},
	TheExodar = {{1056.77, 704.688}},
	TheEyeofEternity = {{430.07, 286.713}},
	TheForgeofSouls = {{1448.1, 965.4}},
	TheMechanar = {{676.238, 450.8254}, {676.238, 450.82534}},
	TheNexus = {{1101.281, 734.1875}},
	TheObsidianSanctum = {{1162.49967, 775}},
	TheRubySanctum = {{752.0833, 502.084}},
	TheShatteredHalls = {{1063.7475, 709.165}},
	TheSlavePens = {{890.0581, 593.372}},
	TheSteamvault = {{876.764, 584.5094}, {876.764, 584.5094}},
	TheStockade = {{378.153, 252.1025}},
	TheStormPeaks = {{7112.5, 4741.67}},
	TheUnderbog = {{894.92, 596.6134}},
	ThousandNeedles = {{4399.9997, 2933.333}},
	ThunderBluff = {{1043.7499, 695.8331}},
	Tirisfal = {{4518.75, 3012.5001}},
	Uldaman = {{893.668, 595.779}, {492.5704, 328.3805}},
	Ulduar = {{669.451, 446.3}, {1328.461, 885.64}, {910.5, 607}, {1569.46, 1046.3}, {619.469, 412.98}},
	Ulduar77 = {{920.196, 613.466}},
	Undercity = {{959.375, 640.104}},
	UngoroCrater = {{3700.0003, 2466.666}},
	UtgardeKeep = {{734.581, 489.7215}, {481.081, 320.7203}, {736.581, 491.0545}},
	UtgardePinnacle = {{548.936, 365.957}, {756.17996, 504.119}},
	VaultofArchavon = {{1398.255, 932.17}},
	VioletHold = {{256.229, 170.82}},
	WarsongGulch = {{1145.8337, 764.5831}},
	WesternPlaguelands = {{4299.9997, 2866.667}},
	Westfall = {{3500.0003, 2333.33}},
	Wetlands = {{4135.4167, 2756.25}},
	Winterspring = {{7100.0003, 4733.333}},
	Zangarmarsh = {{5027.083, 3352.084}},
	Zort = {{470.027, 470.08}},
	ZulAman = {{1268.7497, 845.8333}},
	ZulDrak = {{4993.75, 3329.167}},
	ZulFarrak = {{1383.3333, 922.916}},
	gilneasbattleground2 = {{1302.083, 868.7504}},
	templeofkotmogu = {{839.583, 560.416}},
	vip_location_map = {{595, 599}},
}

---------------
--  Globals  --
---------------
DBM.RangeCheck = {}


--------------
--  Locals  --
--------------
local rangeCheck = DBM.RangeCheck
local checkFuncs = {}
local frame
local createFrame
local radarFrame
local createRadarFrame
local onUpdate
local onUpdateRadar
local dropdownFrame
local initializeDropdown
local initRangeCheck -- initializes the range check for a specific range (if necessary), returns false if the initialization failed (because of a map range check in an unknown zone)
local dots = {}
local charms = {}

-- for Phanx' Class Colors
local RAID_CLASS_COLORS = CUSTOM_CLASS_COLORS or RAID_CLASS_COLORS

local CHARM_TEX_COORDS = {
	[1] = 	{ 0,	0.25, 0,    0.25 },
	[2] = 	{ 0.25, 0.5,  0,    0.25 },
	[3] = 	{ 0.5, 	0.75, 0,    0.25 },
	[4] = 	{ 0.75, 1,    0,    0.25 },
	[5] = 	{ 0, 	0.25, 0.25, 0.5  },
	[6] = 	{ 0.25, 0.5,  0.25, 0.5  },
	[7] = 	{ 0.5, 	0.75, 0.25, 0.5  },
	[8] = 	{ 0.75, 1,    0.25, 0.5  }
}

--local hexColors = {}
local vertexColors = {}
for k, v in pairs(RAID_CLASS_COLORS) do
--	hexColors[k] = ("|cff%02x%02x%02x"):format(v.r * 255, v.g * 255, v.b * 255)
	vertexColors[k] = { v.r, v.g, v.b }
end
---------------------
--  Dropdown Menu  --
---------------------

-- todo: this dropdown menu is somewhat ugly and unflexible....
	local function setFrames(self, option)
		DBM.Options.RangeFrameFrames = option
		radarFrame:Hide()
		frame:Hide()
		rangeCheck:Show(frame.range, frame.filter)
	end

do
	local function setRange(self, range)
		rangeCheck:Show(range)
	end

	local sound0 = "none"
	local sound1 = "Interface\\AddOns\\DBM-Core\\Sounds\\blip_8.ogg"
	local sound2 = "Interface\\AddOns\\DBM-Core\\Sounds\\alarmclockbeeps.ogg"
	local function setSound(self, option, sound)
		DBM.Options[option] = sound
		if sound ~= "none" then
			PlaySoundFile(sound)
		end
	end


--	local function setSpeed(self, option)
--		DBM.Options.RangeFrameUpdates = option
--	end

	local function toggleLocked()
		DBM.Options.RangeFrameLocked = not DBM.Options.RangeFrameLocked
	end

	local function toggleRadar()
		DBM.Options.RangeFrameRadar = not DBM.Options.RangeFrameRadar
		if DBM.Options.RangeFrameRadar then
			radarFrame = radarFrame or createRadarFrame()
			radarFrame:Show()
		else
			radarFrame:Hide()
		end
	end

	function initializeDropdown(dropdownFrame, level, menu)
		local info
		if level == 1 then
			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_SETRANGE
			info.notCheckable = true
			info.hasArrow = true
			info.menuList = "range"
			UIDropDownMenu_AddButton(info, 1)

			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_SOUNDS
			info.notCheckable = true
			info.hasArrow = true
			info.menuList = "sounds"
			UIDropDownMenu_AddButton(info, 1)

			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_OPTION_FRAMES
			info.notCheckable = true
			info.hasArrow = true
			info.menuList = "frames"
			UIDropDownMenu_AddButton(info, 1)

--[[			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_OPTION_SPEED
			info.notCheckable = true
			info.hasArrow = true
			info.menuList = "speed"
			UIDropDownMenu_AddButton(info, 1)]]

			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_LOCK
			if DBM.Options.RangeFrameLocked then
				info.checked = true
			end
			info.func = toggleLocked
			UIDropDownMenu_AddButton(info, 1)

			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_HIDE
			info.notCheckable = true
			info.func = rangeCheck.Hide
			info.arg1 = rangeCheck
			UIDropDownMenu_AddButton(info, 1)

		elseif level == 2 then
			if menu == "range" then

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(5)
					info.func = setRange
					info.arg1 = 5
					info.checked = (frame.range == 5)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(6)
					info.func = setRange
					info.arg1 = 6
					info.checked = (frame.range == 6)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(7)
					info.func = setRange
					info.arg1 = 7
					info.checked = (frame.range == 7)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(8)
					info.func = setRange
					info.arg1 = 8
					info.checked = (frame.range == 8)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(9)
					info.func = setRange
					info.arg1 = 9
					info.checked = (frame.range == 9)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(10)
					info.func = setRange
					info.arg1 = 10
					info.checked = (frame.range == 10)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(11)
					info.func = setRange
					info.arg1 = 11
					info.checked = (frame.range == 11)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(12)
					info.func = setRange
					info.arg1 = 12
					info.checked = (frame.range == 12)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(13)
					info.func = setRange
					info.arg1 = 13
					info.checked = (frame.range == 13)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(14)
					info.func = setRange
					info.arg1 = 14
					info.checked = (frame.range == 14)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(15)
					info.func = setRange
					info.arg1 = 15
					info.checked = (frame.range == 15)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(20)
					info.func = setRange
					info.arg1 = 20
					info.checked = (frame.range == 20)
					UIDropDownMenu_AddButton(info, 2)
				end

				if initRangeCheck() then
					info = UIDropDownMenu_CreateInfo()
					info.text = DBM_CORE_RANGECHECK_SETRANGE_TO:format(28)
					info.func = setRange
					info.arg1 = 28
					info.checked = (frame.range == 28)
					UIDropDownMenu_AddButton(info, 2)
				end


			elseif menu == "sounds" then
				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_SOUND_OPTION_1
				info.notCheckable = true
				info.hasArrow = true
				info.menuList = "RangeFrameSound1"
				UIDropDownMenu_AddButton(info, 2)

				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_SOUND_OPTION_2
				info.notCheckable = true
				info.hasArrow = true
				info.menuList = "RangeFrameSound2"
				UIDropDownMenu_AddButton(info, 2)
			elseif menu == "frames" then
				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_OPTION_TEXT
				info.func = setFrames
				info.arg1 = "text"
				info.checked = (DBM.Options.RangeFrameFrames == "text")
				UIDropDownMenu_AddButton(info, 2)

				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_OPTION_RADAR
				info.func = setFrames
				info.arg1 = "radar"
				info.checked = (DBM.Options.RangeFrameFrames == "radar")
				UIDropDownMenu_AddButton(info, 2)

				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_OPTION_BOTH
				info.func = setFrames
				info.arg1 = "both"
				info.checked = (DBM.Options.RangeFrameFrames == "both")
				UIDropDownMenu_AddButton(info, 2)
--[[			elseif menu == "speed" then
				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_OPTION_SLOW
				info.func = setSpeed
				info.arg1 = "Slow"
				info.checked = (DBM.Options.RangeFrameUpdates == "Slow")
				UIDropDownMenu_AddButton(info, 2)

				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_OPTION_AVERAGE
				info.func = setSpeed
				info.arg1 = "Average"
				info.checked = (DBM.Options.RangeFrameUpdates == "Average")
				UIDropDownMenu_AddButton(info, 2)

				info = UIDropDownMenu_CreateInfo()
				info.text = DBM_CORE_RANGECHECK_OPTION_FAST
				info.func = setSpeed
				info.arg1 = "Fast"
				info.checked = (DBM.Options.RangeFrameUpdates == "Fast")
				UIDropDownMenu_AddButton(info, 2)	]]
			end
		elseif level == 3 then
			local option = menu
			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_SOUND_0
			info.func = setSound
			info.arg1 = option
			info.arg2 = sound0
			info.checked = (DBM.Options[option] == sound0)
			UIDropDownMenu_AddButton(info, 3)

			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_SOUND_1
			info.func = setSound
			info.arg1 = option
			info.arg2 = sound1
			info.checked = (DBM.Options[option] == sound1)
			UIDropDownMenu_AddButton(info, 3)

			info = UIDropDownMenu_CreateInfo()
			info.text = DBM_CORE_RANGECHECK_SOUND_2
			info.func = setSound
			info.arg1 = option
			info.arg2 = sound2
			info.checked = (DBM.Options[option] == sound2)
			UIDropDownMenu_AddButton(info, 3)
		end
	end
end

-----------------
-- Play Sounds --
-----------------
local function updateSound(numPlayers) -- called every 5 seconds
	if not UnitAffectingCombat("player") then
		return
	end
	if numPlayers == 1 then
		if DBM.Options.RangeFrameSound1 ~= "none" then
			PlaySoundFile(DBM.Options.RangeFrameSound1)
		end
	elseif numPlayers > 1 then
		if DBM.Options.RangeFrameSound2 ~= "none" then
			PlaySoundFile(DBM.Options.RangeFrameSound2)
		end
	end
end

------------------------
--  Create the frame  --
------------------------
function createFrame()
	local elapsed = 0
--[[	local updateRate
	if DBM.Options.RangeFrameUpdates == "Slow" then
		updateRate = 0.5
	elseif DBM.Options.RangeFrameUpdates == "Average" then
		updateRate = 0.25
	elseif DBM.Options.RangeFrameUpdates == "Fast" then
		updateRate = 0.05
	end]]
	local frame = CreateFrame("GameTooltip", "DBMRangeCheck", UIParent, "GameTooltipTemplate")
	dropdownFrame = CreateFrame("Frame", "DBMRangeCheckDropdown", frame, "UIDropDownMenuTemplate")
	frame:SetFrameStrata("DIALOG")
	frame:SetPoint(DBM.Options.RangeFramePoint, UIParent, DBM.Options.RangeFramePoint, DBM.Options.RangeFrameX, DBM.Options.RangeFrameY)
	frame:SetHeight(64)
	frame:SetWidth(64)
	frame:EnableMouse(true)
	frame:SetToplevel(true)
	frame:SetMovable()
	GameTooltip_OnLoad(frame)
	frame:SetPadding(16)
	frame:RegisterForDrag("LeftButton")
	frame:SetScript("OnDragStart", function(self)
		if not DBM.Options.RangeFrameLocked then
			self:StartMoving()
		end
	end)
	frame:SetScript("OnDragStop", function(self)
		self:StopMovingOrSizing()
		ValidateFramePosition(self)
		local point, _, _, x, y = self:GetPoint(1)
		DBM.Options.RangeFrameX = x
		DBM.Options.RangeFrameY = y
		DBM.Options.RangeFramePoint = point
	end)
	frame:SetScript("OnUpdate", function(self, e)
		elapsed = elapsed + e
		if elapsed >= 0.05 and self.checkFunc then
			onUpdate(self, elapsed)
			elapsed = 0
		end
	end)
	frame:SetScript("OnMouseDown", function(self, button)
		if button == "RightButton" then
			UIDropDownMenu_Initialize(dropdownFrame, initializeDropdown, "MENU")
			ToggleDropDownMenu(1, nil, dropdownFrame, "cursor", 5, -10)
		end
	end)
	return frame
end

function createRadarFrame()
	local elapsed = 0
--[[	local updateRate
	if DBM.Options.RangeFrameUpdates == "Slow" then
		updateRate = 0.5
	elseif DBM.Options.RangeFrameUpdates == "Average" then
		updateRate = 0.25
	elseif DBM.Options.RangeFrameUpdates == "Fast" then
		updateRate = 0.05
	end]]
	local radarFrame = CreateFrame("Frame", "DBMRangeCheckRadar", UIParent)
	radarFrame:SetFrameStrata("DIALOG")
	radarFrame:SetPoint(DBM.Options.RangeFramePoint, UIParent, DBM.Options.RangeFramePoint, DBM.Options.RangeFrameX, DBM.Options.RangeFrameY)
	radarFrame:SetHeight(128)
	radarFrame:SetWidth(128)
	radarFrame:EnableMouse(true)
	radarFrame:SetToplevel(true)
	radarFrame:SetMovable()
	radarFrame:RegisterForDrag("LeftButton")
	radarFrame:SetScript("OnDragStart", function(self)
		if not DBM.Options.RangeFrameLocked then
			self:StartMoving()
		end
	end)
	radarFrame:SetScript("OnDragStop", function(self)
		self:StopMovingOrSizing()
		ValidateFramePosition(self)
		local point, _, _, x, y = self:GetPoint(1)
		DBM.Options.RangeFrameRadarX = x
		DBM.Options.RangeFrameRadarY = y
		DBM.Options.RangeFrameRadarPoint = point
	end)
	radarFrame:SetScript("OnUpdate", function(self, e)
		elapsed = elapsed + e
		if elapsed >= 0.05 then
			onUpdateRadar(self, elapsed)
			elapsed = 0
		end
	end)
	radarFrame:SetScript("OnMouseDown", function(self, button)
		if button == "RightButton" then
			UIDropDownMenu_Initialize(dropdownFrame, initializeDropdown, "MENU")
			ToggleDropDownMenu(1, nil, dropdownFrame, "cursor", 5, -10)
		end
	end)

	local bg = radarFrame:CreateTexture(nil, "BACKGROUND")
	bg:SetAllPoints(radarFrame)
	bg:SetBlendMode("BLEND")
	bg:SetTexture(0, 0, 0, 0.3)
	radarFrame.background = bg

	local circle = radarFrame:CreateTexture(nil, "ARTWORK")
	circle:SetPoint("CENTER")
	circle:SetTexture("Interface\\AddOns\\DBM-Core\\textures\\radar_circle.blp")
	circle:SetBlendMode("ADD")
	radarFrame.circle = circle

	local player = radarFrame:CreateTexture(nil, "OVERLAY")
	player:SetSize(32, 32)
	player:SetTexture("Interface\\Minimap\\MinimapArrow.blp")
	player:SetBlendMode("ADD")
	player:SetPoint("CENTER")

	local text = radarFrame:CreateFontString(nil, "OVERLAY","GameTooltipText")
	text:SetWidth(128)
	text:SetHeight(15)
	text:SetPoint("BOTTOMLEFT", radarFrame, "TOPLEFT", 0,0)
--	text:SetFont("Fonts\\FRIZQT__.TTF", 11)
	text:SetTextColor(1, 1, 1, 1)
	text:Show()
	radarFrame.text = text

--	for i=1, 40 do
--		local dot = CreateFrame("Frame", "DBMRangeCheckRadarDot"..i, radarFrame, "WorldMapPartyUnitTemplate")
--		dot:SetWidth(24)
--		dot:SetHeight(24)
--		dot:SetFrameStrata("TOOLTIP")
--		dot:Hide()
--		dots[i] = {dot = dot}
--	end
	for i=1, 8 do
		local charm = radarFrame:CreateTexture("DBMRangeCheckRadarCharm"..i, "OVERLAY")
		charm:SetTexture("interface\\targetingframe\\UI-RaidTargetingIcons.blp")
		charm:SetWidth(16)
		charm:SetHeight(16)
		charm:SetTexCoord(
			CHARM_TEX_COORDS[i][1],
			CHARM_TEX_COORDS[i][2],
			CHARM_TEX_COORDS[i][3],
			CHARM_TEX_COORDS[i][4]
		)
		charm:Hide()
		charms[i] = charm
	end

	radarFrame:Hide()
	return radarFrame
end

----------------
--  OnUpdate  --
----------------

local soundUpdate = 0
function onUpdate(self, elapsed)
	local color
	local j = 0
	self:ClearLines()
	self:SetText(DBM_CORE_RANGECHECK_HEADER:format(self.range), 1, 1, 1)
	if initRangeCheck(self.range) then
		if GetNumRaidMembers() > 0 then
			for i = 1, GetNumRaidMembers() do
				local uId = "raid"..i
				if not UnitIsUnit(uId, "player") and not UnitIsDeadOrGhost(uId) and self.checkFunc(uId, self.range) and (not self.filter or self.filter(uId)) then
					j = j + 1
					color = RAID_CLASS_COLORS[select(2, UnitClass(uId))] or NORMAL_FONT_COLOR
					local icon = GetRaidTargetIndex(uId)
					local text = icon and ("|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_%d:0|t %s"):format(icon, UnitName(uId)) or UnitName(uId)
					self:AddLine(text, color.r, color.g, color.b)
					if j >= 5 then
						break
					end
				end
			end
		elseif GetNumPartyMembers() > 0 then
			for i = 1, GetNumPartyMembers() do
				local uId = "party"..i
				if not UnitIsUnit(uId, "player") and not UnitIsDeadOrGhost(uId) and self.checkFunc(uId, self.range) and (not self.filter or self.filter(uId)) then
					j = j + 1
					color = RAID_CLASS_COLORS[select(2, UnitClass(uId))] or NORMAL_FONT_COLOR
					local icon = GetRaidTargetIndex(uId)
					local text = icon and ("|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_%d:0|t %s"):format(icon, UnitName(uId)) or UnitName(uId)
					self:AddLine(text, color.r, color.g, color.b)
					if j >= 5 then
						break
					end
				end
			end
		end
	else
		self:AddLine(DBM_CORE_RANGE_CHECK_ZONE_UNSUPPORTED:format(self.range))
	end
	soundUpdate = soundUpdate + elapsed
	if soundUpdate >= 5 and j > 0 then
		updateSound(j)
		soundUpdate = 0
	end
	self:Show()
end

do
	local rotation, pixelsperyard, prevNumPlayers, range, isInSupportedArea
	local function createDot(id)
		local dot = radarFrame:CreateTexture("DBMRangeCheckRadarDot"..id, "OVERLAY")
		dot:SetTexture([[Interface\AddOns\DBM-Core\textures\blip]])
		dot:SetWidth(16)
		dot:SetHeight(16)
		dot:Hide()

		dots[id].dot = dot	-- store the dot so we can use it later again
		return dot
	end

	local function setDotColor(id, class)
		if class and class == dots[id].class then return end

		dots[id].dot:SetVertexColor(unpack(vertexColors[class]))
		dots[id].class = class
	end

	local function setDot(id, icon, filtered)
		local dot = dots[id].dot or createDot(id)		-- load the dot, or create a new one if none exists yet (creating new probably never happens as the dots are created when the frame is created)
		local x = dots[id].x
		local y = dots[id].y
		local range = (x*x + y*y) ^ 0.5
		if range < (1.5 * frame.range) then							-- if person is closer than 1.5 * range, show the dot. Else hide it
			local dx = ((x * math.cos(rotation)) - (-y * math.sin(rotation))) * pixelsperyard		-- Rotate the X,Y based on player facing
			local dy = ((x * math.sin(rotation)) + (-y * math.cos(rotation))) * pixelsperyard

			if icon and type(icon) == "number" and icon >= 1 and icon <= 8 then -- GetRaidTargetIndex seems to return strange values sometimes; see http://www.deadlybossmods.com/phpbb3/viewtopic.php?f=2&t=3213&p=30889#p30889
				if dots[id].icon and dots[id].icon ~= icon then
					charms[dots[id].icon]:Hide()
				end
				if not filtered then
					charms[icon]:ClearAllPoints()
					charms[icon]:SetPoint("CENTER", radarFrame, "CENTER", dx, dy)
					charms[icon]:Show()
				else
					charms[icon]:Hide()
				end
				dot:Hide()
				dots[id].icon = icon
			elseif not filtered then
				dot:ClearAllPoints()
				dot:SetPoint("CENTER", radarFrame, "CENTER", dx, dy)
				dot:Show()
				if dots[id].icon then
					charms[dots[id].icon]:Hide()
					dots[id].icon = nil
				end
			else
				if dots[id].icon and dots[id].icon ~= icon then
					charms[dots[id].icon]:Hide()
					dots[id].icon = nil
				end
				dot:Hide()
			end
		else
			dot:Hide()
			if dots[id].icon then
				charms[dots[id].icon]:Hide()
				dots[id].icon = nil
			end
		end
		if range < 1.10 * frame.range and not filtered then		-- add an  extra 10% in case of inaccuracy
			dots[id].tooClose = true
		else
			dots[id].tooClose = false
		end
	end

	function onUpdateRadar(self, elapsed)
		if initRangeCheck(frame.range) then--This is basically fixing a bug with map not being on right dungeon level half the time.
			pixelsperyard = min(radarFrame:GetWidth(), radarFrame:GetHeight()) / (frame.range * 3)
			radarFrame.circle:SetSize(frame.range * pixelsperyard * 2, frame.range * pixelsperyard * 2)

			if frame.range ~= (range or 0) then
				range = frame.range
				radarFrame.text:SetText(DBM_CORE_RANGERADAR_HEADER:format(range))
			end

			local mapName = GetMapInfo()
			local level = GetCurrentMapDungeonLevel()
			if level == 0 then level = 1 end
			local dims  = DBM.MapSizes[mapName] and DBM.MapSizes[mapName][level]
			if not dims then -- This ALWAYS happens when leaving a zone that has a map and moving into one that does not.
				if select(3, radarFrame.circle:GetVertexColor()) < 0.5 then
					radarFrame.circle:SetVertexColor(1,1,1)
				end
				for i, v in pairs(dots) do
					v.dot:Hide()
				end
				for i = 1, 8 do
					charms[i]:Hide()
				end
			else
				isInSupportedArea = true
				rotation = (2 * math.pi) - GetPlayerFacing()
				local numPlayers = 0
				local unitID = "raid%d"
				if GetNumRaidMembers() > 0 then
					unitID = "raid%d"
					numPlayers = GetNumRaidMembers()
				elseif GetNumPartyMembers() > 0 then
					unitID = "party%d"
					numPlayers = GetNumPartyMembers()
				end
				if numPlayers < (prevNumPlayers or 0) then
					for i=numPlayers, prevNumPlayers do
						if dots[i] then
							if dots[i].dot then
								dots[i].dot:Hide()		-- Hide dots when people leave the group
							end
							dots[i].tooClose = false
							dots[i].icon = nil
						end
					end
					for i=1, 8 do
						charms[i]:Hide()
					end
				end
				prevNumPlayers = numPlayers

				local playerX, playerY = GetPlayerMapPosition("player")
				if playerX == 0 and playerY == 0 then
					setFrames(self, "text")
					print("Radar is unavailable in this location: GetPlayerMapPosition(\"player\") = 0, 0")
				return end		-- Somehow we can't get the correct position?

				for i=1, numPlayers do
					local uId = unitID:format(i)
					if not UnitIsUnit(uId, "player") then
						local x,y = GetPlayerMapPosition(uId)
						if UnitIsDeadOrGhost(uId) then x = 100 end	-- hack to make sure dead people aren't shown
						if not dots[i] then
							dots[i] = {
								icon = nil,
								class = "none",
								x = (x - playerX) * dims[1],
								y = (y - playerY) * dims[2]
							}
						else
							dots[i].x = (x - playerX) * dims[1]
							dots[i].y = (y - playerY) * dims[2]
						end
						setDot(i, GetRaidTargetIndex(uId), (frame.filter and not frame.filter(uId)))
						setDotColor(i, (select(2, UnitClass(uId))))
					else
						if dots[i] and dots[i].dot then
							dots[i].dot:Hide()
						end
					end
				end

				local playerTooClose = false
				for i,v in pairs(dots) do
					if v.tooClose then
						playerTooClose = true
						break;
					end
				end
				if UnitIsDeadOrGhost("player") then
					radarFrame.circle:SetVertexColor(1,1,1)
				elseif playerTooClose then
					radarFrame.circle:SetVertexColor(1,0,0)
				else
					radarFrame.circle:SetVertexColor(0,1,0)
				end
				self:Show()
			end
		else
			if isInSupportedArea then
				-- we were in an area with known map dimensions during the last update but looks like we left it
				isInSupportedArea = false
				-- white frame
				radarFrame.circle:SetVertexColor(1,1,1)
				-- hide everything
				for i, v in pairs(dots) do
					v.dot:Hide()
				end
				for i = 1, 8 do
					charms[i]:Hide()
				end
			end
		end
	end
end


-----------------------
--  Check functions  --
-----------------------
checkFuncs[11] = function(uId)
	return CheckInteractDistance(uId, 2)
end


checkFuncs[10] = function(uId)
	return CheckInteractDistance(uId, 3)
end

checkFuncs[28] = function(uId)
	return CheckInteractDistance(uId, 4)
end


local getDistanceBetween
do
	local mapSizes = DBM.MapSizes

	function getDistanceBetween(uId, x, y)
		local startX, startY = GetPlayerMapPosition(uId)
		local mapName = GetMapInfo()
		local level = GetCurrentMapDungeonLevel()
		if level == 0 then level = 1 end
		local dims = mapSizes[mapName] and mapSizes[mapName][level]
		if not dims then
			return
		end
		local dX = (startX - x) * dims[1]
		local dY = (startY - y) * dims[2]
		return math.sqrt(dX * dX + dY * dY)
	end

	local function mapRangeCheck(uId, range)
		return getDistanceBetween(uId, GetPlayerMapPosition("player")) < range
	end

	function initRangeCheck(range)
		if checkFuncs[range] ~= mapRangeCheck then
			return true
		end
		local pX, pY = GetPlayerMapPosition("player")
		if pX == 0 and pY == 0 then
			SetMapToCurrentZone()
			pX, pY = GetPlayerMapPosition("player")
		end
		local levels = mapSizes[GetMapInfo()]
		if not levels then
			return false
		end
		local level = GetCurrentMapDungeonLevel()
		if level == 0 then level = 1 end
		local dims = levels[level]
		if not dims and levels and GetCurrentMapDungeonLevel() == 0 then -- we are in a known zone but the dungeon level seems to be wrong
			SetMapToCurrentZone() -- fixes the dungeon level
			dims = levels[GetCurrentMapDungeonLevel()] -- try again
			if not dims then -- there is actually a level 0 in this zone but we don't know about it...too bad :(
				return false
			end
		elseif not dims then
			return false
		end
		return true -- everything ok!
	end

	setmetatable(checkFuncs, {
		__index = function(t, k)
			return mapRangeCheck
		end
	})
end

do
	local bandages = {21991, 34721, 34722, 53049, 53050, 53051}  -- you should have one of these bandages in your cache

	checkFuncs[15] = function(uId)
		for i, v in ipairs(bandages) do
			if IsItemInRange(v, uId) == 1 then
				return true
			elseif IsItemInRange(v, uId) == 0 then
				return false
			end
		end
	end
end

---------------
--  Methods  --
---------------
function rangeCheck:Show(range, filter)
	SetMapToCurrentZone()--Set map to current zone before checking other stuff, work around annoying bug i hope?
	if type(range) == "function" then -- the first argument is optional
		return self:Show(nil, range)
	end
	local mapName = GetMapInfo()
	range = range or 10
	frame = frame or createFrame()
	radarFrame = radarFrame or createRadarFrame()
	frame.checkFunc = checkFuncs[range] or error(("Range \"%d yd\" is not supported."):format(range), 2)
	frame.range = range
	frame.filter = filter
	local level = GetCurrentMapDungeonLevel()
	if level == 0 then level = 1 end
	if DBM.Options.RangeFrameFrames == "text" or DBM.Options.RangeFrameFrames == "both" or not DBM.MapSizes[mapName] or (DBM.MapSizes[mapName] and not DBM.MapSizes[mapName][level]) then
		frame:Show()
		frame:SetOwner(UIParent, "ANCHOR_PRESERVE")
		onUpdate(frame, 0)
	end
	if (DBM.Options.RangeFrameFrames == "radar" or DBM.Options.RangeFrameFrames == "both") and (DBM.MapSizes[mapName] and DBM.MapSizes[mapName][level]) then
		onUpdateRadar(radarFrame, 1)
	end
end

function rangeCheck:Hide()
	if frame then frame:Hide() end
	if radarFrame then radarFrame:Hide() end
end

function rangeCheck:IsShown()
	return frame and frame:IsShown() or radarFrame and radarFrame:IsShown()
end

function rangeCheck:GetDistance(...)
	if initRangeCheck() then
		return getDistanceBetween(...)
	end
end
